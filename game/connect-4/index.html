<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Connect Four - Enhanced Edition</title>
    <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: "Poppins", sans-serif;
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      overflow-y: auto;
    }
    
    /* Animated background */
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="none"/><circle cx="20" cy="20" r="2" fill="rgba(255,255,255,0.1)"/><circle cx="80" cy="40" r="3" fill="rgba(255,255,255,0.1)"/><circle cx="40" cy="80" r="1" fill="rgba(255,255,255,0.1)"/></svg>');
      animation: backgroundMove 60s linear infinite;
      z-index: -1;
    }
    
    @keyframes backgroundMove {
      0% { transform: translate(0, 0); }
      100% { transform: translate(100px, 100px); }
    }
    
    .wrapper {
      width: 90%;
      max-width: 600px;
      background-color: rgba(255, 255, 255, 0.95);
      border-radius: 1.5em;
      padding: 2em;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
      transform: translateY(0);
      transition: transform 0.5s ease;
      margin: 2em 0;
    }
    
    .wrapper::before {
      content: "";
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #1e3c72, #2a5298, #1e3c72);
      border-radius: 1.5em;
      opacity: 0;
      z-index: -1;
      transition: opacity 0.5s ease;
    }
    
    .wrapper:hover::before {
      opacity: 0.7;
    }
    
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5em;
    }
    
    .game-title {
      font-size: 2.2em;
      font-weight: 700;
      color: #1e3c72;
      text-align: center;
      width: 100%;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .game-options {
      display: none; /* Hidden in main game, moved to start screen */
      gap: 10px;
      margin-bottom: 1em;
    }
    
    .option-btn {
      flex: 1;
      padding: 0.8em;
      background-color: #1e3c72;
      color: white;
      border: none;
      border-radius: 0.5em;
      font-family: "Poppins", sans-serif;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .option-btn:hover {
      background-color: #162b50;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(30, 60, 114, 0.4);
    }
    
    .option-btn.active {
      background-color: #2a5298;
    }
    
    .difficulty-container {
      display: none;
      margin-bottom: 1em;
      justify-content: center;
      gap: 10px;
    }
    
    .difficulty-btn {
      padding: 0.5em 1em;
      background-color: #f0f0f0;
      color: #333;
      border: none;
      border-radius: 0.5em;
      font-family: "Poppins", sans-serif;
      font-size: 0.9em;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .difficulty-btn:hover {
      background-color: #e0e0e0;
    }
    
    .difficulty-btn.active {
      background-color: #1e3c72;
      color: white;
    }
    
    #playerTurn {
      text-align: center;
      font-size: 1.3em;
      margin-bottom: 1em;
      color: #333;
      font-weight: 500;
      min-height: 1.5em;
    }
    
    #playerTurn span {
      font-weight: 700;
      color: #1e3c72;
    }
    
    .timer-container {
      display: flex;
      justify-content: center;
      margin-bottom: 1em;
    }
    
    .timer {
      font-size: 1.5em;
      font-weight: 700;
      color: #333;
      padding: 0.5em 1em;
      background-color: #f0f0f0;
      border-radius: 0.5em;
      min-width: 80px;
      text-align: center;
    }
    
    .timer.warning {
      color: #e74c3c;
      background-color: #ffecec;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .container {
      margin: 1.25em auto;
      width: 100%;
      max-width: 500px;
      border-radius: 0.6em;
      overflow: hidden;
      background-color: #1e3c72;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      position: relative;
    }
    
    .container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 10px;
      background: linear-gradient(90deg, #1e3c72, #2a5298);
    }
    
    #information {
      display: grid;
      width: 100%;
      grid-template-columns: 1fr 1fr;
      gap: 1em;
      margin-top: 1.5em;
    }
    
    .player-wrappers {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1em;
      border-radius: 0.8em;
      background-color: #f9f9f9;
      transition: all 0.3s ease;
    }
    
    .player-wrappers.active {
      background-color: #e9f0ff;
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(30, 60, 114, 0.3);
    }
    
    .player-wrappers h3 {
      margin-bottom: 0.5em;
      color: #333;
      font-weight: 600;
    }
    
    .player-wrappers .score {
      font-size: 1.2em;
      font-weight: 700;
      color: #1e3c72;
      margin-top: 0.5em;
    }
    
    .player1:before {
      content: "";
      display: inline-block;
      width: 4em;
      height: 4em;
      border-radius: 50%;
      background: radial-gradient(#fff04e 1.5em, #ffc400 1.6em);
      box-shadow: 0 5px 15px rgba(255, 196, 0, 0.4);
      transition: transform 0.3s ease;
    }
    
    .player1:hover:before {
      transform: scale(1.1);
    }
    
    .player2:before {
      content: "";
      display: inline-block;
      width: 4em;
      height: 4em;
      border-radius: 50%;
      background: radial-gradient(#ff4747 1.5em, #c00303 1.6em);
      box-shadow: 0 5px 15px rgba(192, 3, 3, 0.4);
      transition: transform 0.3s ease;
    }
    
    .player2:hover:before {
      transform: scale(1.1);
    }
    
    .startScreen {
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      width: 100vw;
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: all 0.5s ease;
    }
    
    .startScreen.hide {
      opacity: 0;
      pointer-events: none;
    }
    
    .startScreen h1 {
      font-size: 3.5em;
      color: white;
      margin-bottom: 1em;
      text-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      animation: fadeInDown 1s ease;
    }
    
    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    #message {
      margin-bottom: 1.5em;
      color: #ffffff;
      font-size: 1.5em;
      text-align: center;
      max-width: 80%;
      animation: fadeIn 1s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .startScreen button {
      background-color: #ffffff;
      color: #1e3c72;
      font-size: 1.4em;
      padding: 1em 2.5em;
      border: none;
      outline: none;
      border-radius: 2em;
      cursor: pointer;
      font-family: "Poppins", sans-serif;
      font-weight: 700;
      transition: all 0.3s ease;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      animation: fadeInUp 1s ease;
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .startScreen button:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
    }
    
    .mode-selection {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 2em;
      animation: fadeIn 1s ease;
    }
    
    .mode-selection h2 {
      color: white;
      font-size: 1.8em;
      margin-bottom: 1em;
      text-align: center;
    }
    
    .mode-buttons {
      display: flex;
      gap: 1.5em;
      margin-bottom: 1.5em;
    }
    
    .mode-btn {
      padding: 1em 2em;
      background-color: rgba(255, 255, 255, 0.9);
      color: #1e3c72;
      border: none;
      border-radius: 1em;
      font-family: "Poppins", sans-serif;
      font-size: 1.2em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      min-width: 200px;
    }
    
    .mode-btn:hover {
      background-color: white;
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    
    .mode-btn.active {
      background-color: #2a5298;
      color: white;
    }
    
    .difficulty-selection {
      display: none;
      flex-direction: column;
      align-items: center;
      margin-bottom: 2em;
      animation: fadeIn 1s ease;
    }
    
    .difficulty-selection h3 {
      color: white;
      font-size: 1.5em;
      margin-bottom: 1em;
      text-align: center;
    }
    
    .difficulty-options {
      display: flex;
      gap: 1em;
    }
    
    .difficulty-option {
      padding: 0.8em 1.5em;
      background-color: rgba(255, 255, 255, 0.9);
      color: #1e3c72;
      border: none;
      border-radius: 0.8em;
      font-family: "Poppins", sans-serif;
      font-size: 1.1em;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .difficulty-option:hover {
      background-color: white;
      transform: translateY(-2px);
    }
    
    .difficulty-option.active {
      background-color: #2a5298;
      color: white;
    }
    
    .grid-row {
      margin: 0 auto;
      display: flex;
    }
    
    .grid-box {
      width: 100%;
      aspect-ratio: 1;
      display: grid;
      place-items: center;
      background: radial-gradient(white 1.7em, #1e3c72 1.8em);
      cursor: pointer;
      position: relative;
      transition: background 0.3s ease;
    }
    
    .grid-box:hover {
      background: radial-gradient(white 1.7em, #162b50 1.8em);
    }
    
    .grid-box.filled {
      cursor: not-allowed;
    }
    
    .grid-box.filled::after {
      content: "";
      position: absolute;
      width: 3.4em;
      height: 3.4em;
      border-radius: 50%;
      animation: dropIn 0.5s ease-out;
    }
    
    @keyframes dropIn {
      0% {
        transform: translateY(-400%);
        opacity: 0;
      }
      70% {
        opacity: 1;
      }
      100% {
        transform: translateY(0);
      }
    }
    
    .grid-box.player1::after {
      background: radial-gradient(#fff04e 1.5em, #ffc400 1.6em);
      box-shadow: 0 5px 15px rgba(255, 196, 0, 0.4);
    }
    
    .grid-box.player2::after {
      background: radial-gradient(#ff4747 1.5em, #c00303 1.6em);
      box-shadow: 0 5px 15px rgba(192, 3, 3, 0.4);
    }
    
    .winning-piece {
      animation: pulse 1s infinite;
    }
    
    .controls {
      display: flex;
      justify-content: center;
      gap: 1em;
      margin-top: 1.5em;
    }
    
    .control-btn {
      padding: 0.8em 1.5em;
      background-color: #f0f0f0;
      color: #333;
      border: none;
      border-radius: 0.5em;
      font-family: "Poppins", sans-serif;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .control-btn:hover {
      background-color: #e0e0e0;
      transform: translateY(-2px);
    }
    
    .sound-toggle {
      position: fixed;
      top: 1em;
      left: 1em;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 50;
    }
    
    .sound-toggle:hover {
      background-color: rgba(255, 255, 255, 0.5);
    }
    
    .sound-icon {
      width: 20px;
      height: 20px;
      position: relative;
    }
    
    .sound-icon::before,
    .sound-icon::after {
      content: "";
      position: absolute;
      background-color: white;
    }
    
    .sound-icon::before {
      width: 6px;
      height: 10px;
      top: 5px;
      left: 7px;
      border-radius: 0 3px 3px 0;
    }
    
    .sound-icon::after {
      width: 10px;
      height: 10px;
      top: 5px;
      left: 13px;
      border-radius: 50%;
      opacity: 0.7;
    }
    
    .sound-icon.muted::after {
      display: none;
    }
    
    .sound-icon.muted::before {
      width: 2px;
      height: 15px;
      top: 2.5px;
      left: 9px;
      transform: rotate(45deg);
    }
    
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #f0f;
      animation: confetti-fall 3s linear forwards;
      z-index: 1000;
    }
    
    @keyframes confetti-fall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .wrapper {
        width: 95%;
        padding: 1.5em;
        margin: 1em 0;
      }
      
      .game-title {
        font-size: 1.8em;
      }
      
      .player1:before,
      .player2:before {
        width: 3em;
        height: 3em;
      }
      
      .startScreen h1 {
        font-size: 2.5em;
      }
      
      .mode-buttons {
        flex-direction: column;
        gap: 1em;
      }
      
      .mode-btn {
        min-width: 250px;
      }
      
      .difficulty-options {
        flex-direction: column;
        gap: 0.8em;
      }
      
      #message {
        font-size: 1.2em;
      }
      
      .startScreen button {
        font-size: 1.2em;
        padding: 0.8em 2em;
      }
    }
    </style>
  </head>
  <body>
    <div class="sound-toggle" id="soundToggle">
      <div class="sound-icon" id="soundIcon"></div>
    </div>
    
    <div class="wrapper">
      <h1 class="game-title">Connect Four</h1>
      
      <div class="game-options">
        <button class="option-btn active" id="twoPlayer">Two Players</button>
        <button class="option-btn" id="onePlayer">vs Computer</button>
      </div>
      
      <div class="difficulty-container" id="difficultyContainer">
        <button class="difficulty-btn" data-level="easy">Easy</button>
        <button class="difficulty-btn active" data-level="medium">Medium</button>
        <button class="difficulty-btn" data-level="hard">Hard</button>
      </div>
      
      <div id="playerTurn">Player <span>1</span>'s Turn</div>
      
      <div class="timer-container">
        <div class="timer" id="timer">30</div>
      </div>
      
      <div class="container"></div>
      
      <div id="information">
        <div class="player-wrappers active" id="player1Wrapper">
          <h3>Player 1</h3>
          <div class="player1"></div>
          <div class="score" id="player1Score">0</div>
        </div>
        <div class="player-wrappers" id="player2Wrapper">
          <h3 id="player2Title">Player 2</h3>
          <div class="player2"></div>
          <div class="score" id="player2Score">0</div>
        </div>
      </div>
      
      <div class="controls">
        <button class="control-btn" id="resetGame">New Game</button>
        <button class="control-btn" id="resetScores">Reset Scores</button>
      </div>
    </div>
    
    <div class="startScreen" id="startScreen">
      <h1>Connect Four</h1>
      
      <div class="mode-selection">
        <h2>Choose Game Mode</h2>
        <div class="mode-buttons">
          <button class="mode-btn active" id="twoPlayerMode">Two Players</button>
          <button class="mode-btn" id="onePlayerMode">vs Computer</button>
        </div>
      </div>
      
      <div class="difficulty-selection" id="difficultySelection">
        <h3>Select Difficulty</h3>
        <div class="difficulty-options">
          <button class="difficulty-option active" data-level="easy">Easy</button>
          <button class="difficulty-option" data-level="medium">Medium</button>
          <button class="difficulty-option" data-level="hard">Hard</button>
        </div>
      </div>
      
      <div id="message">Welcome! Select a game mode to start playing</div>
      <button id="start">Start Game</button>
    </div>
    
    <script>
    // Initial references
    const container = document.querySelector(".container");
    const playerTurn = document.getElementById("playerTurn");
    const startScreen = document.getElementById("startScreen");
    const startButton = document.getElementById("start");
    const message = document.getElementById("message");
    const twoPlayerBtn = document.getElementById("twoPlayer");
    const onePlayerBtn = document.getElementById("onePlayer");
    const difficultyContainer = document.getElementById("difficultyContainer");
    const difficultyBtns = document.querySelectorAll(".difficulty-btn");
    const player1Wrapper = document.getElementById("player1Wrapper");
    const player2Wrapper = document.getElementById("player2Wrapper");
    const player2Title = document.getElementById("player2Title");
    const player1Score = document.getElementById("player1Score");
    const player2Score = document.getElementById("player2Score");
    const resetGameBtn = document.getElementById("resetGame");
    const resetScoresBtn = document.getElementById("resetScores");
    const timerElement = document.getElementById("timer");
    const soundToggle = document.getElementById("soundToggle");
    const soundIcon = document.getElementById("soundIcon");
    
    // Start screen elements
    const twoPlayerModeBtn = document.getElementById("twoPlayerMode");
    const onePlayerModeBtn = document.getElementById("onePlayerMode");
    const difficultySelection = document.getElementById("difficultySelection");
    const difficultyOptions = document.querySelectorAll(".difficulty-option");
    
    let initialMatrix = [
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
    ];
    let currentPlayer;
    let gameMode = 'twoPlayer'; // 'twoPlayer' or 'onePlayer'
    let difficulty = 'medium'; // 'easy', 'medium', 'hard'
    let gameActive = true;
    let timer;
    let timeLeft = 30;
    let soundEnabled = true;
    let scores = {
      player1: 0,
      player2: 0
    };
    
    // Load saved scores
    if (localStorage.getItem('connect4Scores')) {
      scores = JSON.parse(localStorage.getItem('connect4Scores'));
      player1Score.textContent = scores.player1;
      player2Score.textContent = scores.player2;
    }
    
    // Create sound effects using Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(frequency, duration) {
      if (!soundEnabled) return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.type = 'sine';
      oscillator.frequency.value = frequency;
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }
    
    function playMoveSound() {
      playSound(440, 0.2);
    }
    
    function playWinSound() {
      playSound(523.25, 0.2);
      setTimeout(() => playSound(659.25, 0.2), 200);
      setTimeout(() => playSound(783.99, 0.4), 400);
    }
    
    function playLoseSound() {
      playSound(349.23, 0.2);
      setTimeout(() => playSound(293.66, 0.2), 200);
      setTimeout(() => playSound(261.63, 0.4), 400);
    }
    
    function playTickSound() {
      playSound(800, 0.05);
    }
    
    // Toggle sound
    soundToggle.addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      soundIcon.classList.toggle('muted', !soundEnabled);
    });
    
    // Start screen mode selection
    twoPlayerModeBtn.addEventListener('click', () => {
      gameMode = 'twoPlayer';
      twoPlayerModeBtn.classList.add('active');
      onePlayerModeBtn.classList.remove('active');
      difficultySelection.style.display = 'none';
      updateStartMessage();
    });
    
    onePlayerModeBtn.addEventListener('click', () => {
      gameMode = 'onePlayer';
      onePlayerModeBtn.classList.add('active');
      twoPlayerModeBtn.classList.remove('active');
      difficultySelection.style.display = 'flex';
      updateStartMessage();
    });
    
    // Difficulty selection on start screen
    difficultyOptions.forEach(btn => {
      btn.addEventListener('click', () => {
        difficultyOptions.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        difficulty = btn.dataset.level;
      });
    });
    
    // Update start screen message based on selected mode
    function updateStartMessage() {
      if (gameMode === 'twoPlayer') {
        message.textContent = "Two Players mode selected. Click Start to play!";
      } else {
        message.textContent = `vs Computer mode selected (${difficulty} difficulty). Click Start to play!`;
      }
    }
    
    // Toggle game mode (for in-game switching)
    twoPlayerBtn.addEventListener('click', () => {
      gameMode = 'twoPlayer';
      twoPlayerBtn.classList.add('active');
      onePlayerBtn.classList.remove('active');
      difficultyContainer.style.display = 'none';
      player2Title.textContent = 'Player 2';
      resetGame();
    });
    
    onePlayerBtn.addEventListener('click', () => {
      gameMode = 'onePlayer';
      onePlayerBtn.classList.add('active');
      twoPlayerBtn.classList.remove('active');
      difficultyContainer.style.display = 'flex';
      player2Title.textContent = 'Computer';
      resetGame();
    });
    
    // Select difficulty level
    difficultyBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        difficultyBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        difficulty = btn.dataset.level;
        if (gameActive && currentPlayer === 2 && gameMode === 'onePlayer') {
          clearTimeout(timer);
          makeComputerMove();
        }
      });
    });
    
    // Random Number Between Range
    const generateRandomNumber = (min, max) =>
      Math.floor(Math.random() * (max - min)) + min;
    
    // Loop through array and check for same values
    const verifyArray = (arrayElement) => {
      let bool = false;
      let elementCount = 0;
      arrayElement.forEach((element, index) => {
        if (element == currentPlayer) {
          elementCount += 1;
          if (elementCount == 4) {
            bool = true;
          }
        } else {
          elementCount = 0;
        }
      });
      return bool;
    };
    
    // Check for game over (Last step)
    const gameOverCheck = () => {
      let truthCount = 0;
      for (let innerArray of initialMatrix) {
        if (innerArray.every((val) => val != 0)) {
          truthCount += 1;
        } else {
          return false;
        }
      }
      if (truthCount == 6) {
        message.innerText = "Game Over! It's a Draw";
        playLoseSound();
        startScreen.classList.remove("hide");
        return true;
      }
      return false;
    };
    
    // Check rows
    const checkAdjacentRowValues = (row) => {
      return verifyArray(initialMatrix[row]);
    };
    
    // Check columns
    const checkAdjacentColumnValues = (column) => {
      let colWinCount = 0,
        colWinBool = false;
      initialMatrix.forEach((element, index) => {
        if (element[column] == currentPlayer) {
          colWinCount += 1;
          if (colWinCount == 4) {
            colWinBool = true;
          }
        } else {
          colWinCount = 0;
        }
      });
      // no match
      return colWinBool;
    };
    
    // Get Right diagonal values
    const getRightDiagonal = (row, column, rowLength, columnLength) => {
      let rowCount = row;
      let columnCount = column;
      let rightDiagonal = [];
      while (rowCount > 0) {
        if (columnCount >= columnLength - 1) {
          break;
        }
        rowCount -= 1;
        columnCount += 1;
        rightDiagonal.unshift(initialMatrix[rowCount][columnCount]);
      }
      rowCount = row;
      columnCount = column;
      while (rowCount < rowLength) {
        if (columnCount < 0) {
          break;
        }
        rightDiagonal.push(initialMatrix[rowCount][columnCount]);
        rowCount += 1;
        columnCount -= 1;
      }
      return rightDiagonal;
    };
    
    const getLeftDiagonal = (row, column, rowLength, columnLength) => {
      let rowCount = row;
      let columnCount = column;
      let leftDiagonal = [];
      while (rowCount > 0) {
        if (columnCount <= 0) {
          break;
        }
        rowCount -= 1;
        columnCount -= 1;
        leftDiagonal.unshift(initialMatrix[rowCount][columnCount]);
      }
      rowCount = row;
      columnCount = column;
      while (rowCount < rowLength) {
        if (columnCount >= columnLength) {
          break;
        }
        leftDiagonal.push(initialMatrix[rowCount][columnCount]);
        rowCount += 1;
        columnCount += 1;
      }
      return leftDiagonal;
    };
    
    // Check diagonal
    const checkAdjacentDiagonalValues = (row, column) => {
      let diagWinBool = false;
      let tempChecks = {
        leftTop: [],
        rightTop: [],
      };
      let columnLength = initialMatrix[row].length;
      let rowLength = initialMatrix.length;
      // Store left and right diagonal array
      tempChecks.leftTop = [
        ...getLeftDiagonal(row, column, rowLength, columnLength),
      ];
      tempChecks.rightTop = [
        ...getRightDiagonal(row, column, rowLength, columnLength),
      ];
      // check both arrays for similarities
      diagWinBool = verifyArray(tempChecks.rightTop);
      if (!diagWinBool) {
        diagWinBool = verifyArray(tempChecks.leftTop);
      }
      return diagWinBool;
    };
    
    // Win check logic
    const winCheck = (row, column) => {
      // if any of the functions return true we return true
      return checkAdjacentRowValues(row)
        ? true
        : checkAdjacentColumnValues(column)
        ? true
        : checkAdjacentDiagonalValues(row, column)
        ? true
        : false;
    };
    
    // Create confetti effect on win
    function createConfetti() {
      const colors = ['#ff4747', '#ffc400', '#1e3c72', '#2a5298', '#00ff00', '#ff00ff'];
      
      for (let i = 0; i < 100; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + '%';
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.width = Math.random() * 10 + 5 + 'px';
          confetti.style.height = Math.random() * 10 + 5 + 'px';
          confetti.style.opacity = Math.random() * 0.5 + 0.5;
          document.body.appendChild(confetti);
          
          setTimeout(() => {
            confetti.remove();
          }, 3000);
        }, i * 30);
      }
    }
    
    // Sets the circle to exact points
    const setPiece = (startCount, colValue) => {
      let rows = document.querySelectorAll(".grid-row");
      // Initially it will place the circles in the last row else if no place available we will decrement the count until we find empty slot
      if (initialMatrix[startCount][colValue] != 0) {
        startCount -= 1;
        setPiece(startCount, colValue);
      } else {
        // place circle
        let currentRow = rows[startCount].querySelectorAll(".grid-box");
        currentRow[colValue].classList.add("filled", `player${currentPlayer}`);
        
        // Update Matrix
        initialMatrix[startCount][colValue] = currentPlayer;
        
        // Play sound
        playMoveSound();
        
        // Check for wins
        if (winCheck(startCount, colValue)) {
          gameActive = false;
          clearTimeout(timer);
          
          // Update scores
          if (currentPlayer === 1) {
            scores.player1++;
            player1Score.textContent = scores.player1;
          } else {
            scores.player2++;
            player2Score.textContent = scores.player2;
          }
          
          // Save scores
          localStorage.setItem('connect4Scores', JSON.stringify(scores));
          
          // Show win message
          const winner = gameMode === 'onePlayer' && currentPlayer === 2 ? 'Computer' : `Player ${currentPlayer}`;
          message.innerHTML = `<span>${winner}</span> Wins!`;
          startScreen.classList.remove("hide");
          
          // Play win sound
          playWinSound();
          
          // Create confetti effect
          createConfetti();
          
          return false;
        }
      }
      
      // Check if all are full
      if (!gameOverCheck()) {
        // Change player
        currentPlayer = currentPlayer == 1 ? 2 : 1;
        updatePlayerTurn();
        
        // Reset timer
        resetTimer();
        
        // If single player mode and computer is next
        if (gameMode === 'onePlayer' && currentPlayer === 2 && gameActive) {
          clearTimeout(timer);
          // Short delay before computer move
          setTimeout(() => makeComputerMove(), 800);
        }
      }
    };
    
    // Update current player UI
    function updatePlayerTurn() {
      playerTurn.innerHTML = `${gameMode === 'onePlayer' && currentPlayer === 2 ? 'Computer' : 'Player ' + currentPlayer}'<span>'s Turn</span>`;
      
      // Update active player UI
      if (currentPlayer === 1) {
        player1Wrapper.classList.add('active');
        player2Wrapper.classList.remove('active');
      } else {
        player1Wrapper.classList.remove('active');
        player2Wrapper.classList.add('active');
      }
    }
    
    // Reset timer
    function resetTimer() {
      clearTimeout(timer);
      timeLeft = 30;
      timerElement.textContent = timeLeft;
      timerElement.classList.remove('warning');
      
      if (gameActive) {
        timer = setInterval(() => {
          timeLeft--;
          timerElement.textContent = timeLeft;
          
          if (timeLeft <= 5) {
            timerElement.classList.add('warning');
            if (soundEnabled) playTickSound();
          }
          
          if (timeLeft <= 0) {
            clearTimeout(timer);
            // Time's up, change player
            currentPlayer = currentPlayer == 1 ? 2 : 1;
            updatePlayerTurn();
            resetTimer();
            
            // If single player mode and computer is next
            if (gameMode === 'onePlayer' && currentPlayer === 2 && gameActive) {
              makeComputerMove();
            }
          }
        }, 1000);
      }
    }
    
    // Computer move
    function makeComputerMove() {
      if (!gameActive || gameMode !== 'onePlayer' || currentPlayer !== 2) return;
      
      let column;
      
      // Different strategy based on difficulty
      if (difficulty === 'easy') {
        // Easy: random move
        const availableColumns = [];
        for (let col = 0; col < 7; col++) {
          if (initialMatrix[0][col] === 0) {
            availableColumns.push(col);
          }
        }
        
        if (availableColumns.length > 0) {
          column = availableColumns[Math.floor(Math.random() * availableColumns.length)];
        }
      } else if (difficulty === 'medium') {
        // Medium: partially smart move
        column = findBestMove(false);
      } else {
        // Hard: fully smart move
        column = findBestMove(true);
      }
      
      if (column !== undefined) {
        // Simulate click on column
        const gridBoxes = document.querySelectorAll('.grid-row:first-child .grid-box');
        if (gridBoxes[column]) {
          fillBox({ target: gridBoxes[column] });
        }
      }
    }
    
    // Find best move for computer
    function findBestMove(isHard) {
      // First, check if computer can win in next move
      for (let col = 0; col < 7; col++) {
        if (initialMatrix[0][col] === 0) {
          // Create a copy of matrix for simulation
          const matrixCopy = JSON.parse(JSON.stringify(initialMatrix));
          
          // Find first empty row in this column
          let row = 5;
          while (row >= 0 && matrixCopy[row][col] !== 0) {
            row--;
          }
          
          if (row >= 0) {
            // Simulate placing computer piece
            matrixCopy[row][col] = 2;
            
            // Check if this move would win
            if (checkWinOnMatrix(matrixCopy, row, col, 2)) {
              return col;
            }
          }
        }
      }
      
      // Second, check if player can win in next move and block
      for (let col = 0; col < 7; col++) {
        if (initialMatrix[0][col] === 0) {
          // Create a copy of matrix for simulation
          const matrixCopy = JSON.parse(JSON.stringify(initialMatrix));
          
          // Find first empty row in this column
          let row = 5;
          while (row >= 0 && matrixCopy[row][col] !== 0) {
            row--;
          }
          
          if (row >= 0) {
            // Simulate placing player piece
            matrixCopy[row][col] = 1;
            
            // Check if this move would win for player
            if (checkWinOnMatrix(matrixCopy, row, col, 1)) {
              return col;
            }
          }
        }
      }
      
      // In hard mode, check for best strategies
      if (isHard) {
        // Try to create opportunities to win
        for (let col = 0; col < 7; col++) {
          if (initialMatrix[0][col] === 0) {
            // Create a copy of matrix for simulation
            const matrixCopy = JSON.parse(JSON.stringify(initialMatrix));
            
            // Find first empty row in this column
            let row = 5;
            while (row >= 0 && matrixCopy[row][col] !== 0) {
              row--;
            }
            
            if (row >= 0) {
              // Simulate placing computer piece
              matrixCopy[row][col] = 2;
              
              // Check if this move creates a winning opportunity in next move
              for (let nextCol = 0; nextCol < 7; nextCol++) {
                if (matrixCopy[0][nextCol] === 0) {
                  let nextRow = 5;
                  while (nextRow >= 0 && matrixCopy[nextRow][nextCol] !== 0) {
                    nextRow--;
                  }
                  
                  if (nextRow >= 0) {
                    matrixCopy[nextRow][nextCol] = 2;
                    
                    if (checkWinOnMatrix(matrixCopy, nextRow, nextCol, 2)) {
                      return col;
                    }
                    
                    // Undo simulation
                    matrixCopy[nextRow][nextCol] = 0;
                  }
                }
              }
            }
          }
        }
        
        // Focus on center column
        if (initialMatrix[0][3] === 0) return 3;
        
        // Focus on columns adjacent to center
        if (initialMatrix[0][2] === 0) return 2;
        if (initialMatrix[0][4] === 0) return 4;
      }
      
      // Random choice from available columns
      const availableColumns = [];
      for (let col = 0; col < 7; col++) {
        if (initialMatrix[0][col] === 0) {
          availableColumns.push(col);
        }
      }
      
      if (availableColumns.length > 0) {
        return availableColumns[Math.floor(Math.random() * availableColumns.length)];
      }
      
      return undefined;
    }
    
    // Check win on specific matrix
    function checkWinOnMatrix(matrix, row, col, player) {
      // Save current player
      const tempPlayer = currentPlayer;
      currentPlayer = player;
      
      // Save original matrix
      const originalMatrix = initialMatrix;
      initialMatrix = matrix;
      
      // Check for win
      const result = checkAdjacentRowValues(row) ||
        checkAdjacentColumnValues(col) ||
        checkAdjacentDiagonalValues(row, col);
      
      // Restore original values
      currentPlayer = tempPlayer;
      initialMatrix = originalMatrix;
      
      return result;
    }
    
    // When user clicks on a box
    const fillBox = (e) => {
      if (!gameActive) return;
      
      // get column value
      let colValue = parseInt(e.target.getAttribute("data-value"));
      
      // 5 because we have 6 rows (0-5)
      setPiece(5, colValue);
    };
    
    // Create Matrix
    const matrixCreator = () => {
      container.innerHTML = "";
      for (let innerArray in initialMatrix) {
        let outerDiv = document.createElement("div");
        outerDiv.classList.add("grid-row");
        outerDiv.setAttribute("data-value", innerArray);
        for (let j in initialMatrix[innerArray]) {
          // Set all matrix values to 0
          initialMatrix[innerArray][j] = 0;
          let innerDiv = document.createElement("div");
          innerDiv.classList.add("grid-box");
          innerDiv.setAttribute("data-value", j);
          innerDiv.addEventListener("click", (e) => {
            fillBox(e);
          });
          outerDiv.appendChild(innerDiv);
        }
        container.appendChild(outerDiv);
      }
    };
    
    // Initialize game
    window.onload = startGame = async () => {
      // Between 1 and 2
      currentPlayer = generateRandomNumber(1, 3);
      gameActive = true;
      
      // Reset matrix
      initialMatrix = [
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
      ];
      
      // Update UI based on selected game mode
      if (gameMode === 'twoPlayer') {
        twoPlayerBtn.classList.add('active');
        onePlayerBtn.classList.remove('active');
        difficultyContainer.style.display = 'none';
        player2Title.textContent = 'Player 2';
      } else {
        onePlayerBtn.classList.add('active');
        twoPlayerBtn.classList.remove('active');
        difficultyContainer.style.display = 'flex';
        player2Title.textContent = 'Computer';
        
        // Update difficulty buttons
        difficultyBtns.forEach(btn => {
          if (btn.dataset.level === difficulty) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      }
      
      await matrixCreator();
      updatePlayerTurn();
      resetTimer();
      
      // If single player mode and computer goes first
      if (gameMode === 'onePlayer' && currentPlayer === 2) {
        clearTimeout(timer);
        setTimeout(() => makeComputerMove(), 1000);
      }
    };
    
    // Start game
    startButton.addEventListener("click", () => {
      startScreen.classList.add("hide");
      startGame();
    });
    
    // Reset game
    resetGameBtn.addEventListener("click", () => {
      resetGame();
    });
    
    function resetGame() {
      clearTimeout(timer);
      startGame();
    }
    
    // Reset scores
    resetScoresBtn.addEventListener("click", () => {
      if (confirm('Are you sure you want to reset all scores?')) {
        scores = {
          player1: 0,
          player2: 0
        };
        player1Score.textContent = scores.player1;
        player2Score.textContent = scores.player2;
        localStorage.setItem('connect4Scores', JSON.stringify(scores));
      }
    });
    </script>
  </body>
</html>